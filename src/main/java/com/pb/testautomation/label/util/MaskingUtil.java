package com.pb.testautomation.label.util;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.apache.log4j.Logger;

import com.pb.testautomation.label.constant.CommonConstants;
import com.pb.testautomation.label.exception.ConfigException;
import com.pb.testautomation.label.exception.LabelException;
import com.pb.testautomation.label.exception.UnknownConversionUnitException;
import com.pb.testautomation.label.model.LabelSpec;
import com.pb.testautomation.label.model.LabelTypeConfig;
import com.pb.testautomation.label.model.MaskableRegion;
import com.pb.testautomation.label.model.Page;
import com.pb.testautomation.label.model.Template;
/**
 * Utility class that handles the masking of images. 
 * @author RA013GU
 *
 */
public class MaskingUtil {
	private static final String JAXP_SCHEMA_LANGUAGE = "http://java.sun.com/xml/jaxp/properties/schemaLanguage";
	private static final String W3C_XML_SCHEMA = "http://www.w3.org/2001/XMLSchema"; 
	private static final String JAXP_SCHEMA_SOURCE = "http://java.sun.com/xml/jaxp/properties/schemaSource";
	
	private Map<String, LabelTypeConfig> configMappings = new HashMap<String, LabelTypeConfig>();
	private static MaskingUtil instance =  new MaskingUtil();
	private Logger logger = Logger.getLogger(MaskingUtil.class);
	/**
	 * Singleton
	 */
	private MaskingUtil(){
		
	}
	
	public static MaskingUtil getInstance(){
		return instance;
	}
	
	/**
	 * @return the configMappings
	 */
	public Map<String, LabelTypeConfig> getConfigMappings() {
		return configMappings;
	}
	/**
	 * Applies mask on the image <code>img</code> by reading specs from the config file.
	 * @param generatedImage - Image file instance generated by PDF2Image util.  
	 * @param img - BufferedImage instance of the generated image.
	 * @return Masked BufferedImage instance.
	 */
	public BufferedImage applyMaskOnGeneratedImg(File generatedImage, BufferedImage img) {
		BufferedImage maskedImage = null;
		String fileName = generatedImage.getName();
		String templateType = fileName.split(LabelUtil.LABEL_TYPE_FILE_NAME_DELIMITER)[0];

		LabelTypeConfig labelTypeConfig = configMappings.get(templateType);
		if(labelTypeConfig != null) {
			int lastUnderScoreIndex = fileName.lastIndexOf(CommonConstants.PDF_PAGE_NUM_TO_IMG_NUM_PREFIX);
			int lastDotIndex = fileName.lastIndexOf(".");
			
			if(lastUnderScoreIndex > - 1 && lastDotIndex > -1 && lastDotIndex > lastUnderScoreIndex) {
				String imageNumberStr = fileName.substring(lastUnderScoreIndex + 1, lastDotIndex);
				
				int imageNumber = Integer.parseInt(imageNumberStr);
				
				Map<Integer, Page> pagesMap = labelTypeConfig.getPagesMap();
				
				if(pagesMap != null && pagesMap.containsKey(imageNumber)) {
					List<LabelSpec> labelSpecs = pagesMap.get(imageNumber).getLabelSpecs();
					try {
						 maskedImage = applyMask(img, labelSpecs, labelTypeConfig.getUom());
					} catch (Exception e) {
						logger.error(Messages.getMessage(CommonConstants.MASKING_EXCEPTION, generatedImage.getAbsolutePath(), e.getMessage()));
					}
				}
			}
		}else{
			logger.info(Messages.getMessage(CommonConstants.INFO_NO_CONFIGURATION_FOUND_IN_CONFIG_FILE, generatedImage.getAbsolutePath()));;
		}
		return maskedImage;
	}
	/**
	 * Applies mask on image <code>img1</code> with specs <code>labelSpecs</code>.
	 * @param img1 - Image to mask.
	 * @param labelSpecs - Masking specifications.
	 * @param uom - Unit of measurement e.g, in, cm or px. 
	 * @return Masked BufferedImage instance.
	 * @throws IOException
	 * @throws LabelException
	 */
	private BufferedImage applyMask(BufferedImage img1,
			List<LabelSpec> labelSpecs, String uom) throws IOException, LabelException {
        int rgb_black = Color.BLACK.getRGB();

        float scale = LabelUtil.getInstance().getScalingFactorForPDF(uom);
        
        for(int i = 0; i < labelSpecs.size(); i++) {
        	LabelSpec labelSpec = labelSpecs.get(i);
        	Template template = labelSpec.getTemplate();

        	for(int  j = 0; j < template.getMaskableRegions().size(); j++) {
        		MaskableRegion maskableRegion = template.getMaskableRegions().get(j);
        		
        		int x = (int) (scale * (labelSpec.getTemplateLeft() + maskableRegion.getLeft()));
        		int y = (int) (scale * (labelSpec.getTemplateTop() + maskableRegion.getTop()));
        		int width = (int) (scale * maskableRegion.getWidth());
        		int height = (int) (scale * maskableRegion.getHeight());
        		
        		for(int col = x; col <= x + width && col < img1.getWidth(); col++) {
        			for(int row = y; row <= y + height && row < img1.getHeight(); row++) {
        				img1.setRGB(col, row, rgb_black);
        			}
        		}
        	}
        	
        }
        return img1;
 }

	
	/**
	 * Loads masking areas in a configuration map by reading from the config file <code>configFile</code>.
	 * @param validateConfigFile 
	 * @throws ConfigException
	 */
	public void loadMaskAreaFromPropertyFile(File configFile, boolean validateConfigFile) throws ConfigException {
		logger.info(Messages.getMessage(CommonConstants.INFO_LOADING_CONFIGURATION_FILE));
		InputStream is = null;
		ConfigFileParser handler = new ConfigFileParser();
		try {
			is = new FileInputStream(configFile);
			SAXParserFactory spf = SAXParserFactory.newInstance();
			spf.setNamespaceAware(validateConfigFile);
			spf.setValidating(validateConfigFile);
			
			SAXParser sp = spf.newSAXParser();
			if(validateConfigFile) {
				sp.setProperty(JAXP_SCHEMA_LANGUAGE, W3C_XML_SCHEMA); 
				
				InputStream in = ClassLoader.getSystemResourceAsStream("config.xsd");
				sp.setProperty(JAXP_SCHEMA_SOURCE, in);				
			}
			
			sp.parse(is, handler);			
			configMappings = handler.getConfigFileMappings();
		} catch(Exception e) {
			if(e instanceof ConfigException) {
				throw (ConfigException)e;
			} else {
				throw new ConfigException(e);				
			}
		} finally {
			if(is != null) {
				try {
					is.close();
				} catch (IOException e) {
					logger.error(Messages.getMessage(CommonConstants.IO_EXCEPTION, "while closing file: " ,configFile.getAbsolutePath(), e.getMessage()));
				}
			}
		}
	}
	

	
}
